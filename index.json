[{"uri":"/issie/reference/global.html","title":"global","content":"ContextMenus \nElectronAPI \nMain","headings":[],"type":"apiDocs"},{"uri":"/issie/reference/global-contextmenus.html","title":"ContextMenus","content":"ContextMenus \n \nContextMenus.contextMenus \ncontextMenus \nContextMenus.menuMap \nmenuMap \nContextMenus.makeClickableReturner \nmakeClickableReturner \nContextMenus.makeMenu \nmakeMenu","headings":[],"type":"apiDocs"},{"uri":"/issie/reference/global-contextmenus.html#contextMenus","title":"ContextMenus.contextMenus","content":"ContextMenus.contextMenus \ncontextMenus \n The context menu info is a map of menu name -\u003E list of menu items\n menu and item names can be arbitrary strings\n add menus as here","headings":[],"type":"apiDocs"},{"uri":"/issie/reference/global-contextmenus.html#menuMap","title":"ContextMenus.menuMap","content":"ContextMenus.menuMap \nmenuMap \n","headings":[],"type":"apiDocs"},{"uri":"/issie/reference/global-contextmenus.html#makeClickableReturner","title":"ContextMenus.makeClickableReturner","content":"ContextMenus.makeClickableReturner \nmakeClickableReturner \n function used to implement main process \n context menu items. It should not be changed.","headings":[],"type":"apiDocs"},{"uri":"/issie/reference/global-contextmenus.html#makeMenu","title":"ContextMenus.makeMenu","content":"ContextMenus.makeMenu \nmakeMenu \n Function implements main process context menus\n it is called in main.fs from the renderer contextmenu event.\n to change which menu is called where alter UpdateHelpers.chooseContextMenu","headings":[],"type":"apiDocs"},{"uri":"/issie/reference/global-electronapi.html","title":"ElectronAPI","content":"ElectronAPI \n \nElectronAPI.Array\u003C\u0027T\u003E \nArray\u003C\u0027T\u003E \nElectronAPI.Document \nDocument \nElectronAPI.EventListenerOrEventListenerObject \nEventListenerOrEventListenerObject \nElectronAPI.ExceptError \nExceptError \nElectronAPI.File \nFile \nElectronAPI.Function \nFunction \nElectronAPI.GlobalEvent \nGlobalEvent \nElectronAPI.HTMLElementEventMap \nHTMLElementEventMap \nElectronAPI.KeyOf\u003C\u0027T\u003E \nKeyOf\u003C\u0027T\u003E \nElectronAPI.MessagePort \nMessagePort \nElectronAPI.NodeEventEmitter \nNodeEventEmitter \nElectronAPI.NodeRequire \nNodeRequire \nElectronAPI.NodeRequireFunction \nNodeRequireFunction \nElectronAPI.Record\u003C\u0027T, \u0027S\u003E \nRecord\u003C\u0027T, \u0027S\u003E \nElectronAPI.String \nString \nElectronAPI.jsToBool \njsToBool","headings":[],"type":"apiDocs"},{"uri":"/issie/reference/global-electronapi.html#jsToBool","title":"ElectronAPI.jsToBool","content":"ElectronAPI.jsToBool \njsToBool \n bool Option -\u003E bool, with None -\u003E false","headings":[],"type":"apiDocs"},{"uri":"/issie/reference/electronapi-array-1.html","title":"Array\u003C\u0027T\u003E","content":"Array\u003C\u0027T\u003E \n \nArray\u003C\u0027T\u003E.Item \nItem","headings":[],"type":"apiDocs"},{"uri":"/issie/reference/electronapi-array-1.html#Item","title":"Array\u003C\u0027T\u003E.Item","content":"Array\u003C\u0027T\u003E.Item \nItem \n","headings":[],"type":"apiDocs"},{"uri":"/issie/reference/electronapi-document.html","title":"Document","content":"Document \n \nDocument.createElement_webview \ncreateElement_webview","headings":[],"type":"apiDocs"},{"uri":"/issie/reference/electronapi-document.html#createElement_webview","title":"Document.createElement_webview","content":"Document.createElement_webview \ncreateElement_webview \n","headings":[],"type":"apiDocs"},{"uri":"/issie/reference/electronapi-eventlisteneroreventlistenerobject.html","title":"EventListenerOrEventListenerObject","content":"EventListenerOrEventListenerObject \n","headings":[],"type":"apiDocs"},{"uri":"/issie/reference/electronapi-excepterror.html","title":"ExceptError","content":"ExceptError \n \nExceptError.Data \nData \nExceptError.HelpLink \nHelpLink \nExceptError.HResult \nHResult \nExceptError.InnerException \nInnerException \nExceptError.Message \nMessage \nExceptError.Source \nSource \nExceptError.StackTrace \nStackTrace \nExceptError.TargetSite \nTargetSite \nExceptError.SerializeObjectState \nSerializeObjectState","headings":[],"type":"apiDocs"},{"uri":"/issie/reference/electronapi-excepterror.html#Data","title":"ExceptError.Data","content":"ExceptError.Data \nData \n","headings":[],"type":"apiDocs"},{"uri":"/issie/reference/electronapi-excepterror.html#HelpLink","title":"ExceptError.HelpLink","content":"ExceptError.HelpLink \nHelpLink \n","headings":[],"type":"apiDocs"},{"uri":"/issie/reference/electronapi-excepterror.html#HResult","title":"ExceptError.HResult","content":"ExceptError.HResult \nHResult \n","headings":[],"type":"apiDocs"},{"uri":"/issie/reference/electronapi-excepterror.html#InnerException","title":"ExceptError.InnerException","content":"ExceptError.InnerException \nInnerException \n","headings":[],"type":"apiDocs"},{"uri":"/issie/reference/electronapi-excepterror.html#Message","title":"ExceptError.Message","content":"ExceptError.Message \nMessage \n","headings":[],"type":"apiDocs"},{"uri":"/issie/reference/electronapi-excepterror.html#Source","title":"ExceptError.Source","content":"ExceptError.Source \nSource \n","headings":[],"type":"apiDocs"},{"uri":"/issie/reference/electronapi-excepterror.html#StackTrace","title":"ExceptError.StackTrace","content":"ExceptError.StackTrace \nStackTrace \n","headings":[],"type":"apiDocs"},{"uri":"/issie/reference/electronapi-excepterror.html#TargetSite","title":"ExceptError.TargetSite","content":"ExceptError.TargetSite \nTargetSite \n","headings":[],"type":"apiDocs"},{"uri":"/issie/reference/electronapi-excepterror.html#SerializeObjectState","title":"ExceptError.SerializeObjectState","content":"ExceptError.SerializeObjectState \nSerializeObjectState \n","headings":[],"type":"apiDocs"},{"uri":"/issie/reference/electronapi-file.html","title":"File","content":"File \n \nFile.path \npath","headings":[],"type":"apiDocs"},{"uri":"/issie/reference/electronapi-file.html#path","title":"File.path","content":"File.path \npath \n The real path to the file on the users filesystem","headings":[],"type":"apiDocs"},{"uri":"/issie/reference/electronapi-function.html","title":"Function","content":"Function \n","headings":[],"type":"apiDocs"},{"uri":"/issie/reference/electronapi-globalevent.html","title":"GlobalEvent","content":"GlobalEvent \n","headings":[],"type":"apiDocs"},{"uri":"/issie/reference/electronapi-htmlelementeventmap.html","title":"HTMLElementEventMap","content":"HTMLElementEventMap \n","headings":[],"type":"apiDocs"},{"uri":"/issie/reference/electronapi-keyof-1.html","title":"KeyOf\u003C\u0027T\u003E","content":"KeyOf\u003C\u0027T\u003E \n \nKeyOf\u003C\u0027T\u003E.Key \nKey","headings":[],"type":"apiDocs"},{"uri":"/issie/reference/electronapi-keyof-1.html#Key","title":"KeyOf\u003C\u0027T\u003E.Key","content":"KeyOf\u003C\u0027T\u003E.Key \nKey \n","headings":[],"type":"apiDocs"},{"uri":"/issie/reference/electronapi-messageport.html","title":"MessagePort","content":"MessagePort \n","headings":[],"type":"apiDocs"},{"uri":"/issie/reference/electronapi-nodeeventemitter.html","title":"NodeEventEmitter","content":"NodeEventEmitter \n \nNodeEventEmitter.defaultMaxListeners \ndefaultMaxListeners","headings":[],"type":"apiDocs"},{"uri":"/issie/reference/electronapi-nodeeventemitter.html#defaultMaxListeners","title":"NodeEventEmitter.defaultMaxListeners","content":"NodeEventEmitter.defaultMaxListeners \ndefaultMaxListeners \n","headings":[],"type":"apiDocs"},{"uri":"/issie/reference/electronapi-noderequire.html","title":"NodeRequire","content":"NodeRequire \n \nNodeRequire.Invoke_electron \nInvoke_electron \nNodeRequire.\u0060\u0060Invoke_electron/common\u0060\u0060 \n\u0060\u0060Invoke_electron/common\u0060\u0060 \nNodeRequire.\u0060\u0060Invoke_electron/main\u0060\u0060 \n\u0060\u0060Invoke_electron/main\u0060\u0060 \nNodeRequire.\u0060\u0060Invoke_electron/renderer\u0060\u0060 \n\u0060\u0060Invoke_electron/renderer\u0060\u0060","headings":[],"type":"apiDocs"},{"uri":"/issie/reference/electronapi-noderequire.html#Invoke_electron","title":"NodeRequire.Invoke_electron","content":"NodeRequire.Invoke_electron \nInvoke_electron \n","headings":[],"type":"apiDocs"},{"uri":"/issie/reference/electronapi-noderequire.html#\u0060\u0060Invoke_electron/common\u0060\u0060","title":"NodeRequire.\u0060\u0060Invoke_electron/common\u0060\u0060","content":"NodeRequire.\u0060\u0060Invoke_electron/common\u0060\u0060 \n\u0060\u0060Invoke_electron/common\u0060\u0060 \n","headings":[],"type":"apiDocs"},{"uri":"/issie/reference/electronapi-noderequire.html#\u0060\u0060Invoke_electron/main\u0060\u0060","title":"NodeRequire.\u0060\u0060Invoke_electron/main\u0060\u0060","content":"NodeRequire.\u0060\u0060Invoke_electron/main\u0060\u0060 \n\u0060\u0060Invoke_electron/main\u0060\u0060 \n","headings":[],"type":"apiDocs"},{"uri":"/issie/reference/electronapi-noderequire.html#\u0060\u0060Invoke_electron/renderer\u0060\u0060","title":"NodeRequire.\u0060\u0060Invoke_electron/renderer\u0060\u0060","content":"NodeRequire.\u0060\u0060Invoke_electron/renderer\u0060\u0060 \n\u0060\u0060Invoke_electron/renderer\u0060\u0060 \n","headings":[],"type":"apiDocs"},{"uri":"/issie/reference/electronapi-noderequirefunction.html","title":"NodeRequireFunction","content":"NodeRequireFunction \n \nNodeRequireFunction.Invoke_electron \nInvoke_electron \nNodeRequireFunction.\u0060\u0060Invoke_electron/common\u0060\u0060 \n\u0060\u0060Invoke_electron/common\u0060\u0060 \nNodeRequireFunction.\u0060\u0060Invoke_electron/main\u0060\u0060 \n\u0060\u0060Invoke_electron/main\u0060\u0060 \nNodeRequireFunction.\u0060\u0060Invoke_electron/renderer\u0060\u0060 \n\u0060\u0060Invoke_electron/renderer\u0060\u0060","headings":[],"type":"apiDocs"},{"uri":"/issie/reference/electronapi-noderequirefunction.html#Invoke_electron","title":"NodeRequireFunction.Invoke_electron","content":"NodeRequireFunction.Invoke_electron \nInvoke_electron \n","headings":[],"type":"apiDocs"},{"uri":"/issie/reference/electronapi-noderequirefunction.html#\u0060\u0060Invoke_electron/common\u0060\u0060","title":"NodeRequireFunction.\u0060\u0060Invoke_electron/common\u0060\u0060","content":"NodeRequireFunction.\u0060\u0060Invoke_electron/common\u0060\u0060 \n\u0060\u0060Invoke_electron/common\u0060\u0060 \n","headings":[],"type":"apiDocs"},{"uri":"/issie/reference/electronapi-noderequirefunction.html#\u0060\u0060Invoke_electron/main\u0060\u0060","title":"NodeRequireFunction.\u0060\u0060Invoke_electron/main\u0060\u0060","content":"NodeRequireFunction.\u0060\u0060Invoke_electron/main\u0060\u0060 \n\u0060\u0060Invoke_electron/main\u0060\u0060 \n","headings":[],"type":"apiDocs"},{"uri":"/issie/reference/electronapi-noderequirefunction.html#\u0060\u0060Invoke_electron/renderer\u0060\u0060","title":"NodeRequireFunction.\u0060\u0060Invoke_electron/renderer\u0060\u0060","content":"NodeRequireFunction.\u0060\u0060Invoke_electron/renderer\u0060\u0060 \n\u0060\u0060Invoke_electron/renderer\u0060\u0060 \n","headings":[],"type":"apiDocs"},{"uri":"/issie/reference/electronapi-record-2.html","title":"Record\u003C\u0027T, \u0027S\u003E","content":"Record\u003C\u0027T, \u0027S\u003E \n \nRecord\u003C\u0027T, \u0027S\u003E.Item1 \nItem1 \nRecord\u003C\u0027T, \u0027S\u003E.Item2 \nItem2","headings":[],"type":"apiDocs"},{"uri":"/issie/reference/electronapi-record-2.html#Item1","title":"Record\u003C\u0027T, \u0027S\u003E.Item1","content":"Record\u003C\u0027T, \u0027S\u003E.Item1 \nItem1 \n","headings":[],"type":"apiDocs"},{"uri":"/issie/reference/electronapi-record-2.html#Item2","title":"Record\u003C\u0027T, \u0027S\u003E.Item2","content":"Record\u003C\u0027T, \u0027S\u003E.Item2 \nItem2 \n","headings":[],"type":"apiDocs"},{"uri":"/issie/reference/electronapi-string.html","title":"String","content":"String \n \nString.Chars \nChars \nString.Length \nLength","headings":[],"type":"apiDocs"},{"uri":"/issie/reference/electronapi-string.html#Chars","title":"String.Chars","content":"String.Chars \nChars \n","headings":[],"type":"apiDocs"},{"uri":"/issie/reference/electronapi-string.html#Length","title":"String.Length","content":"String.Length \nLength \n","headings":[],"type":"apiDocs"},{"uri":"/issie/reference/global-main.html","title":"Main","content":"Main \n \nMain.args \nargs \nMain.argFlagIsOn \nargFlagIsOn \nMain.hasDebugArgs \nhasDebugArgs \nMain.electronRemote \nelectronRemote \nMain.debug \ndebug \nMain.isMacos \nisMacos \nMain.isWin \nisWin \nMain.mainWindow \nmainWindow \nMain.printListeners \nprintListeners \nMain.staticDir \nstaticDir \nMain.closeAfterSave \ncloseAfterSave \nMain.wait \nwait \nMain.dispatchToRenderer \ndispatchToRenderer \nMain.createMainWindow \ncreateMainWindow \nMain.startRenderer \nstartRenderer \nMain.loadAppIntoWidowWhenReady \nloadAppIntoWidowWhenReady \nMain.addListeners \naddListeners \nMain.startup \nstartup","headings":[],"type":"apiDocs"},{"uri":"/issie/reference/global-main.html#args","title":"Main.args","content":"Main.args \nargs \n","headings":[],"type":"apiDocs"},{"uri":"/issie/reference/global-main.html#argFlagIsOn","title":"Main.argFlagIsOn","content":"Main.argFlagIsOn \nargFlagIsOn \n Returns true if any of flags are present as command line argument.    ","headings":[],"type":"apiDocs"},{"uri":"/issie/reference/global-main.html#hasDebugArgs","title":"Main.hasDebugArgs","content":"Main.hasDebugArgs \nhasDebugArgs \n","headings":[],"type":"apiDocs"},{"uri":"/issie/reference/global-main.html#electronRemote","title":"Main.electronRemote","content":"Main.electronRemote \nelectronRemote \n Fix to access the deprecated @electron.remote module.\n This must be enabled from main.fs\n NB the interface used here is not precisely correct, because it\n exposes the original electron-remote API. The @electron.remote API is\n a bit reduced, but with some extra code to control access.\n electronRemote replaces electron.remote and renderer.remote in old interface","headings":[],"type":"apiDocs"},{"uri":"/issie/reference/global-main.html#debug","title":"Main.debug","content":"Main.debug \ndebug \n","headings":[],"type":"apiDocs"},{"uri":"/issie/reference/global-main.html#isMacos","title":"Main.isMacos","content":"Main.isMacos \nisMacos \n","headings":[],"type":"apiDocs"},{"uri":"/issie/reference/global-main.html#isWin","title":"Main.isWin","content":"Main.isWin \nisWin \n","headings":[],"type":"apiDocs"},{"uri":"/issie/reference/global-main.html#mainWindow","title":"Main.mainWindow","content":"Main.mainWindow \nmainWindow \n","headings":[],"type":"apiDocs"},{"uri":"/issie/reference/global-main.html#printListeners","title":"Main.printListeners","content":"Main.printListeners \nprintListeners \n","headings":[],"type":"apiDocs"},{"uri":"/issie/reference/global-main.html#staticDir","title":"Main.staticDir","content":"Main.staticDir \nstaticDir \n","headings":[],"type":"apiDocs"},{"uri":"/issie/reference/global-main.html#closeAfterSave","title":"Main.closeAfterSave","content":"Main.closeAfterSave \ncloseAfterSave \n","headings":[],"type":"apiDocs"},{"uri":"/issie/reference/global-main.html#wait","title":"Main.wait","content":"Main.wait \nwait \n","headings":[],"type":"apiDocs"},{"uri":"/issie/reference/global-main.html#dispatchToRenderer","title":"Main.dispatchToRenderer","content":"Main.dispatchToRenderer \ndispatchToRenderer \n","headings":[],"type":"apiDocs"},{"uri":"/issie/reference/global-main.html#createMainWindow","title":"Main.createMainWindow","content":"Main.createMainWindow \ncreateMainWindow \n","headings":[],"type":"apiDocs"},{"uri":"/issie/reference/global-main.html#startRenderer","title":"Main.startRenderer","content":"Main.startRenderer \nstartRenderer \n","headings":[],"type":"apiDocs"},{"uri":"/issie/reference/global-main.html#loadAppIntoWidowWhenReady","title":"Main.loadAppIntoWidowWhenReady","content":"Main.loadAppIntoWidowWhenReady \nloadAppIntoWidowWhenReady \n","headings":[],"type":"apiDocs"},{"uri":"/issie/reference/global-main.html#addListeners","title":"Main.addListeners","content":"Main.addListeners \naddListeners \n","headings":[],"type":"apiDocs"},{"uri":"/issie/reference/global-main.html#startup","title":"Main.startup","content":"Main.startup \nstartup \n","headings":[],"type":"apiDocs"},{"uri":"/issie/verilogComp.html","title":"Verilog Components","content":"\nISSIE Verilog Components\nIntroduction\nIssie allows a component defined by Verilog source code to be placed\non any sheet from the Catalog. The component behaviour is defined by\nits synthesisable Verilog which can be opened and edited from Properties. The editor provides syntax highlighting and error checking.\nSyntax\nBoth old and new style syntax are supported.\nOld style example\nmodule decoder(instr,carry,negative,jump,mux1_sel,mux2_sel);\n    input [15:0] instr;\n    input carry,negative;\n    output jump,mux1_sel,mux2_sel;\n\n    wire [3:0] opc = instr[15:12];\n\n    assign jump = opc[0] ? c|n : c\u0026amp;n|op[1]; \n    assign mux1_sel = (\u0026amp;op[3:2]);\n    assign mux2_sel = negative;\n\nendmodule\n\nNew style example\nmodule decoder(\n    input [15:0] instr,\n    input carry,negative,\n    output jump,mux1_sel,mux2_sel\n);\n\n    wire [3:0] opc = instr[15:12];\n\n    assign jump = opc[0] ? c|n : c\u0026amp;n|op[1]; \n    assign mux1_sel = (\u0026amp;op[3:2]);\n    assign mux2_sel = negative;\n\nendmodule\n\nNumbers\nNumbers are given in the form: {width}\u0027{radix}{value}, where radix = \u0027b or \u0027d or \u0027h\ne.g. 16\u0027h3fa5 , 4\u0027b0101, 16\u0027d154\nOperators\nOperators perform an operation on one or more operands within an expression. An expression combines operands with appropriate operators to produce the desired functional expression.\nThe table shows the operators in descending order of precedence. Operators with equal precedence are shown grouped.\n\n\n\nVerilog Operator\nName\nNotes and example\n\n\n\n\n[ ]\nbit-select or part-select\nUsed to select specific bits of a bus signal. Example: instr[15:8]\n\n\n( )\nparenthesis\nUsed to define the order of operations. Example:  (a \u0026verbar; b) \u0026amp; c\n\n\n!  ~  (\u0026amp;)  (\\|)  (~\u0026amp;)  (~\\|)\nlogical negation  negation  reduction AND  reduction OR  reduction NAND  reduction NOR\nThe Verilog reduction operators are used to convert vectors to scalars. They operate on all of the bits in a vector to convert the answer to a single bit.  AND Reduction of 4\u0027b1101 is: 0  AND Reduction of 4\u0027b1111 is: 1  OR Reduction of 4\u0027b1101 is: 1  OR Reduction of 4\u0027b0000 is: 0  Example: assign out = (\u0026amp;a);\n\n\n{ }\nconcatenation\nExample: {a[2:0],b[3:2],2\u0027b01} -\u0026gt; result is 7 bits\n\n\n\u002B  \u2013\nbinary plus  binary minus\nThe two operands must be of equal width N. The result is also N bits.\n\n\n \u003E\u003E  \u003E\u003E\u003E\nlogical shift left  logical shift right  arithmetic shift right\nThe second operand of a shift is an unsigned integer. Example: assign out[5:0] = in[5:0]  The result has the width of the input.\n\n\n\u0026amp;\nbit-wise AND\nThe two operands must have the same width.\n\n\n^  ~^ or ^~\nbit-wise XOR  bit-wise XNOR\nAs above.\n\n\n\\|\nbit-wise OR\nAs above.\n\n\n\u0026amp;\u0026amp;\nlogical AND\nLogical means that 0-\u0026gt;false, anything else -\u0026gt; true. Operands can have different width.\n\n\n\\|\\|\nlogical OR\nAs above.\n\n\n\n\n| ? : | conditional | Like an if-statement, corresponds to a MUX. Example: assign jump = opc[0] ? c|n : c\u0026amp;n|op[1]; |\n","headings":["ISSIE Verilog Components","Introduction","Syntax","Old style example","New style example","Numbers","Operators"],"type":"content"},{"uri":"/issie/contact.html","title":"Contacts","content":"\nContacts\nIf you encounter any problems using or downloading the software, please see the Gihub Issue page, or create a new issue on the ISSIE GitHub repository. Any feedback and suggestions are also welcome - we keep feature request issues and usually manage to implement them!\nIf you want to use ISSIE in an educational context contact Dr. Tom Clarke, Department of Electronic \u0026amp; Electrical Engineering, Imperial College London.\n","headings":["Contacts"],"type":"content"},{"uri":"/issie/gettingStarted.html","title":"Getting Started","content":"\nGetting Started\nUsers\nGo to the latest ISSIE release. Scroll down this page till at the bottom you find the Assets section - this has binaries for Windows and Macos and linux PCs. Download the appropriate one and unzip it anywhere (or add the dmg file to applications under Macos by double-clicking).\nNo installation is required - ISSIE runs from the unzipped files under windows if you double-click the top-level issie.exe file with the blue ISSIE chip icon. The Windows binaries are currently unsigned\nIssie is designed to be intuitive with no manual required. Users will find the one page User Tutorial here is a useful introduction to Issie features. It can be skimmed quickly to see what is possible, or followed in detail for an easy introduction.\nCreating binaries\nIt is possible for users to create their own binaries from source, if for example the latest release does not have an uploaded set of binaries. Binaries for a given platform can be created on that platform and run successfully without signing. Follow the steps in Getting Started.\nDevelopers\nSee the  Getting Started section of the repo README for how to develop Issie code.\nDevelopment is possible on Macos or Windows.\nResources for developers\n\n\nThe ISSIE wiki has information on the details of how ISSIE is designed:\n\nCoding guidelines\nCode Overview\nDetails of main algorithms\n\n\nThe Reports page has some long technical reports on parts of ISSIE.\nF# XML documentation on the ISSIE API\n\n","headings":["Getting Started","Users","Creating binaries","Developers","Resources for developers"],"type":"content"},{"uri":"/issie/Updating the documentation.html","title":"Updating This Documentation","content":"\nUpdating the documentation\nIntroduction\nThe ISSIE documentation is generated by fsdocs from Markdown documents using a Github action build .github/workflows/ci.yml. This action outputs a static website as generated by fsdocs to the root directory on the gh-pages branch of the repo. Changes to this branch are automatically deployed to the documentation website.\nTo change the documentation PR the markdown files to ISSIE master, rebuilding will be automatic when the changes are committed to master.\nThe Markdown source files can be found on the ISSIE repo:\n\nDocumentation Pages: /docs/*.md\nISSIE Blog Pages: /docs/updates/*.md\nEmbedded (PNG) graphics: /docs/img/**/*.md\nIn documentation source files the file path separator is always /\n\nHow to develop documentation\nFor developer preview of changes  use dotnet fsdocs watch --noapidocs in the repo root directory. The documentation (without API) will be generated and a browser window opened to preview. Changes will get reloaded automatically.\nSee Issue 532 for more details of why watch does not work with API.\nPR to ISSIE master the changed documentation.\nGotcha\nDocumentation builds for ISSIE need a secret key on the repo generated as documented on the wiki.\nThis must be regenerated every 6 months or so and uploaded to the repo.\n","headings":["Updating the documentation","Introduction","How to develop documentation","Gotcha"],"type":"content"},{"uri":"/issie/issiestick.html","title":"ISSIE-Stick FPGA hardware","content":"\nSynthesis to FPGAs (e.g. the ISSIE-Stick hardware)\nThe Issie Stick is a USB plug-in that will interface with ISSIE to run ISSIE hardware on an FPGA.\nTo use this, Sheet -\u0026gt; Verilog output\nThe instructions there reference the README of a separate github project issie-synth.\nMore documentation needed here!\n","headings":["Synthesis to FPGAs (e.g. the ISSIE-Stick hardware)"],"type":"content"},{"uri":"/issie/verilogGenerate.html","title":"Verilog Output","content":"\nVerilog output\nISSIE can output any design as synthesisable or simulatable Verilog HDL. Every ISSIE design sheet is turned into a single Verilog module. The Verilog output Sheet menu item leads to a dialog screen:\n\nThe buttons provide help on how to generate and use output with Verilog simulation or the Issie-stick FPGA hardware.\nVerilog output is not currently used much: but the code to generate it is very simple and easily changed. Please add issues if what currently exists does not fit your requirements.\n","headings":["Verilog output"],"type":"content"},{"uri":"/issie/index.html","title":"Home","content":"\nIssie Documentation Home\nSee Getting Started for how to put Issie on your laptop or develop Issie.\nSee User Tutorial for a useful introduction to Issie on one page which you can follow or read.\n\nWhat is ISSIE?\n\nISSIE is an easy-to-use schematic editor and simulator for hierarchical design of digital logic circuits. Run it and see the built-in demos for what it can do! ISSIE is targeted at 1st year university students, but would be useful teaching in schools and even for quick hardware design and test in an industrial or research environment. For the latter use case although we allow Verilog input and output these features need a bit more work to be as complete and nice as the rest of ISSIE.\n\nISSIE was motivated because we found that industry-standard CAD systems were too complex and buggy to be learnt in labs, and when learnt still nasty to use. Other educational products were too limited. We wanted a system to teach hierarchical design and digital electronics visually that would scale to large designs.\n\nWe find that EEE-educated internal PhD candidates starting with schematic logic designs usually have a better understanding of what digital hardware is than those from other institutions starting with HDL.\n\n\nISSIE has as a design principle that it should be easy to use by a novice, with all errors well highlighted. Error messages telling the user what the error is and how precisely to correct it, so a novice user can make the correction. Keeping to this principle has been challenging but worthwhile. We also wanted a complete system capable of real design work: good user interface is separate from large-scale features and performance and there is no reason they cannot both be implemented.\nISSIE is developed by undergraduate students and staff at Imperial College London. The code is cross-platform and binaries are released for Windows and Silicon (Arm64) Mac and Linux platforms.\nISSIE is implemented using nearly 50K lines in the Functional-first language F#, the equivalent of 150K lines in a typical OOP language. ISSIE\u0027s implementation is (almost) pure functional programming without assignment. This makes the codebase very maintainable! ISSIE has its own digital simulator, which uses write-once semantics on mutable (JS typed) arrays to combine the robustness of functional programming with high performance.\nISSIE uses the FABLE F# to Javascript compiler, Elmish MVU framework, and Electron. This tool chain creates seamless cross-platform applications with simple and highly productive coding.\nISSIE can generate Verilog output to drive FPGAs and has an integrated system to do this directly using ISSIE-Stick hardware.\nISSIE can also accept Verilog source, using this to define and simulate equivalent schematic components.\nFor acronym geeks, ISSIE stands for: Interactive Schematic Simulator with Integrated Editor.\n\n\nISSIE Development Roadmap\n2024\n\nWorkaround unexpected \u0026amp; undocumented React 17 memory leak\nBetter user interface to Waveform Simulator\nLonger simulation times keeping waveforms in memory\nAutomatic whole-circuit wire segment separation for almost perfect auto-routing\n\n2025\n\nNew Waveform Selector for waveform simulations (complete)\nTooltips on waveform simulator waveforms (complete)\nSymbolic parameters to make component bit-widths etc adjustable (in progress)\nImprovements to Verilog parser and to-Issie synthesis (in progress)\nSee Issue 506 for possible other changes.\n\n\nAcknowledgements\n\nMarco Selvatici for the 8K lines of base code written for his 3rd year BEng FYP at Imperial College London.\nEdoardo Santi for work improving ISSIE over Summer 2020 and creating the waveform simulator\nHigh Level Programming 2020/21 cohort for providing the base code of the new all-F# schematic editor AKA draw block\nJo Merrick for work improving ISSIE for her 3rd year BEng FYP\nHigh Level Programming 2021/22 cohort for implementing a much enhanced schematic editor\nAll 2020/2021 1st year undergraduate students of the EEE department, Imperial College London, for acting as excellent and unpaid beta-testers in their DECA module\nJason Zheng for improving the waveform simulator for his 4th year MEng FYP\nAditya Deshpande for creating the truth table simulation for his 4th year MEng FYP\nArchontis Pantelopoulos for creating the Verilog editor and compiler and improving ISSIE over Summer 2022\nPetra Ratkai and Yujie Wang for improving the Verilog compiler \u0026amp; ISSIE simulator respectively in 2022-23.\nThe High Level Programming 22/23 cohort for adding many features to the schematic editor\nSamuel Wang for on-demand waveform creation and a software scrollbar to improve the waveform simulator over Summer 2024.\nThe High Level Programming 24/25 cohort for new waveform selector and design sheet parameter mechanism\n\nDr Tom Clarke (Imperial College London, EEE department) for running HLP and his continued work maintaining and improving ISSIE code throughout\n\n\n\n","headings":["Issie Documentation Home","What is ISSIE?","ISSIE Development Roadmap","2024","2025","Acknowledgements"],"type":"content"},{"uri":"/issie/coolFeatures.html","title":"Schematic Editor Features","content":"\nSummary of Schematic Editor Operations\nISSIE features developed over several years to help you create readable schematics very quickly. These are summarised in the table below:\n\n\n\nFeature\nHow\nExplanation\n\n\n\n\nSize-to-fit\nCtrl-W\nMost often used keyboard shortcut to zoom and centre schematic so it is all fitted onto the screen at the correct zoom.\n\n\nChange port location on Custom Components\nPress CTRL and use your mouse to drag a port to another position on the outline of the symbol\nCustom components may end up having a large number of ports. You can move them to your desired location on the outline to create nicer schematics\n\n\nResizing of Custom Components\nChange Width Scale and Height Scale on the properties pane\nIf default sizing makes port legends overlap you can scale custom component width and height in Properties\n\n\nMove component\u0027s label\nSimply drag the component\u0027s label to your desired location on the canvas\n\n\n\nRotate and flip components\nCtrl \u002B left arrow:  Ctrl \u002B right arrow:   Ctrl \u002B up arrow:   Ctrl \u002B down arrow:\nRotate clockwise  Rotate anti-clockwise  Flip vertically  Flip horizontally\n\n\nTruth Table for combinational logic\nSimulations -\u0026gt; Truth Table\nView the truth table for a combinational logic circuit. This can be either a full sheet or a sub-set by selecting the components you want to be included in the truth table\n\n\nAdd a description on your sheets\nDe-select all components and click on properties. Click the Add Description button\nSheet description will appear on the sheet list as an \u0026#9432; button and will be displayed on properties when that sheet is used as a custom component\n\n\nThemes\nView -\u0026gt; Theme\nChoose between the 3 supported themes: Grayscale, Light or Colourful\n\n\nGrid\nView -\u0026gt; Toggle grid\nChoose whether you want a grid to appear on your sheets\n\n\nWire Type\nView -\u0026gt; Wire Type\nChoose between the 3 supported wire types: Jump, Radiussed or Modern wires\n\n\nWire Arrows\nView -\u0026gt; Toggle Wire Arrows\nChoose whether you want arrows at the end-points of your wires to show the direction of signals\n\n\nAuto-routing with fixed segments\n\nIssie will nearly always route and separate all schematic connections neatly with no manual routing required. Any wire segment can be manually dragged to a desired position and \u0022fixed\u0022 with other segments and wires auto-routed around it.\n\n\nRight-click context menus\nRight-click on any schematic component or the background sheet will give you useful actions\n\n\n\nKeyboard shortcuts\nMost actions have shortcuts documented from the main info button or individually on menus.\n\n\n\n\n\n\nDetails of wire routing and symbol alignment\nSnapping\nThis allows symbol edges to stick to other symbol edges when moving them in ISSIE, or symbols to stick to positions that make wires straight.\nExplicit arrangement\nSelections of same-type components can be aligned vertically or horizontally, or distributed with equal spacing. Differing type components are omitted from the operation even if selected.\nManual wire routing\nManual routing has been reworked to have the following behaviour:\n\nA non-binding segment can be dragged anywhere\nA binding segment cannot be dragged past the nubLength of the wire, which is the minimum length of the nubs coming out of the ports (defined as static member nubLength in Wire type)\n\nA segment is defined as binding for a particular port if it is the first segment of non-zero length perpendicular to the port\u0027s nub.\nWire auto-routing\nAuto-routing is done in 5 stages:\n\nNormalise the routing problem so that the output port is facing right\nGenerate the initial segment list\nRotate the problem back to it\u0027s in the original orientation\nRun an iterative autorouting algorithm that attempts to create a valid route not overlapping any symbol by moving initial segments.\nRun a whole-sheet segment separation algorithm that spreads wires out evenly.\n\nInitial segment List\nSegments are generated based off of the two ports for each wire, with the assumption that the output port is always facing right. The orientation of the input port is checked as well as its relative position to the output port, allowing us to generate an initial segment list. This segment list consists of a small \u201Cnub\u201D segment immediately joining the input and output port. These are followed by 0 length segments in order to facilitate previous functionality of ISSIE where we could drag wires fully. After these 0 length segments we create the remaining segments to link the two ports. These distances are either set to halfway between the two ports, or a small distance in order to get past the boundaries of a symbol.\n\nDetails of Operations\nCopy and paste\nThe on-screen copy \u0026amp; paste buttons can duplicate single components, or selected sets of components (see selection below). They can also be used to copy components from one design sheet to a new one.\nCanvas zooming\nThe canvas can be zoomed in or out, or auto-zoomed and panned to fit the whole circuit using Ctrl-W (Cmd-W).\nSymbol rotation\nIndividual symbols can be rotated or flipped using the right-click menu or the Issie edit menu.\nWire display types\nWires can be displayed as radial, modern, or old-style jump. Switching display types can be done at any time and does not chnage the schematic.\nRadial wires are the mots interesting (and readable) form of wire display. Wire bends have small quadrant connections thus distinguishing between wires that cross and a wire joining two perpendicular wires. Visually, radial display makes connectivity easier to follow. The default radius for the wire quadrants is defined as static member radius = 5.0 in Wire type. However, for very small wires, this radius is changed to prevent visual bugs. When drawing radii, the length of the smallest segment the curve connects to is checked, and if its length is \u0026lt;5, the radius is shrunk to match it. Due to the limitations of drawing Arcs in SVG, these radii can only be integer valued, leading to small inconsistencies when a segment is a small non integer value (i.e. 1.5).\nSymbol auto-sizing\nCustom components (symbols) are dynamically resized depending on their port configuration. The minimum distance distance between 2 ports is set as GridSize = 30, which is defined as a [\u0026lt;Literal\u0026gt;] at the top of Symbol.fs. The dimensions of a component are determined as follows:\n\nHeight: Determined purely from the maximum number of ports on the left or right edge (n), setting the height to (n\u002B1)GridSize, and spreading the ports GridSize apart.\nWidth: The distance between ports is determined by the maximum between the largest port label and GridSize. This ensures that the labels of the ports cannot overlap, whilst still being a minimum distance apart. The width can be calculated for both the Top and Bottom edges using the same approach as above using the maximum value, and taking the largest of these 2 values. In addition, the length of the longest labels from the Left and Right sides, as well as the component label (displayed in the center of the component) are added up and compared to the width obtained from the previous calculation. By selecting the component width as the maximum of these values, it can be ensured that labels associated with the component / ports do not overlap.\n\nCustom components\u0027 ports can be placed to different edges on the Symbol by pressing Ctrl (Cmd) and dragging the port.\nWhen a port is dragged onto a different edge, the width and height of the component is automatically resized. The ports on one edge are always equidistant. The height of the component is determined purely from the number of ports on the left or right edge, depending on which one has more ports. The width of the component also considers the lengths of the ports on the top and bottom edges. The distance between ports on the top and bottom edges is big enough, such that it can fit the longest portlabel on the edge, but never smaller than 1 gridsize. The necessary width of the top/bottom edge is determined from this distance and from the number of ports on this edge. The width of the component is given by either the top or bottom edge width, whichever is bigger.\nThe same UI (dragging component corners) can be used manually to override auto-sizing and make the custom symbol a desired size.\nPort placement\nThe ordering of the ports on  a custom symbol is represented by its index in the list associated to a particular edge of the Symbol (Top, Left, Bottom, Right). We allow ports to be moved for custom components by clicking and dragging the port while holding down the Ctrl key.\nSchematic rotation and scaling\nAny group of components on the schematic can be selected, and then rotated and/or scaled.\n\nDragging the mouse will select a rectangle.\nShift-click will add or remove a component from the current  selection.\nA selected block of components will show icons for intuitive rotating and scaling.\n\n","headings":["Summary of Schematic Editor Operations","Details of wire routing and symbol alignment","Snapping","Explicit arrangement","Manual wire routing","Wire auto-routing","Initial segment List","Details of Operations","Copy and paste","Canvas zooming","Symbol rotation","Wire display types","Symbol auto-sizing","Port placement","Schematic rotation and scaling"],"type":"content"},{"uri":"/issie/userGuide.html","title":"User Tutorial","content":"\nGetting Started\nDownloading and Running ISSIE\nFind the latest ISSIE release. At the bottom of the page, you can find the latest pre-built binary for your platform (Windows or ARM64 Macos). ISSIE will require in total about 200M of disk space.\n\nWindows: unzip *.zip anywhere and double-click the top-level Issie.exe application in the unzipped files.\n\nMacOS: Double click the dmg file  and run the application inside the folder, or drag and drop this to install.\n\nThe MacOs binaries are signed.\n\n\n\nIf you can\u0027t find a binary:\n\n\nMacOs binaries are sometimes not uptodate. You can always generate your only binary by \nsetting up for development and running npm run dist. This will not need to be signed if runnng on your own machine. Note that you do not need to edit source code to generate a binary.\n\nYou can look through previous releases to find the last posted binary for your system. However ISSIE newer releases often have significant new functionality and bug fixes. It is best to have the latest release,\n\n\n\nCreating a New Project\nOnce you open ISSIE you should see two options: New Project and Open Project.\n\nClick New Project\nNavigate to the folder you want to save your project\nEnter the name of your project\nClick Create Project\n\nThis process creates a folder where your project will be stored and the first sheet of your project, called main. You can see this by clicking at the Sheets selection button.\nYour first design\nLet\u0027s start with a very simple schematic: a simple 2-input AND gate.\nAdd the following components to your canvas from the Catalogue tab:\n\nINPUT/OUTPUT =\u0026gt; Input =\u0026gt; Name: \u0027A\u0027, Bits: 1\nINPUT/OUTPUT =\u0026gt; Input =\u0026gt; Name: \u0027B\u0027, Bits: 1\nGATES =\u0026gt; And\nINPUT/OUTPUT =\u0026gt; Output =\u0026gt; Name: \u0027OUT\u0027, Bits: 1\n\nNow make the appropriate wiring to connect all the components by clicking on one port and dragging the wire to the port you want to connect it to.\nConnect:\n\nInput \u0027A\u0027 to the first input port of the AND gate\nInput \u0027B\u0027 to the second input port of the AND gate\nOutput \u0027OUT\u0027 to the output port of the AND gate\n\nYour design should look like this:\n\nSimulation\nTime to simulate the design and see how the output OUT changes as we change the two inputs.\nClick the Simulation tab which is located on the top-right corner and then Start Simulation. Now you can change the value of the two inputs and see how the value of the output. Try all 4 combinations of inputs:\n\nA=0, B=0\nA=0, B=1\nA=1, B=0\nA=1, B=1\n\nand check that the output is correct based on the truth table of the AND gate.\n\nWell Done! You just completed your first ISSIE design.\nExploiting the ISSIE Features\nA slightly more complex design\nThis section will exploit the features of ISSIE to create clean and good-looking schematics when making bigger designs.\n\nAdd two more inputs named C and D each 1-bit.\nAdd one OR gate and one 2-input MUX\n\nDelete the output OUT\n\nNote: You can delete components and/or wires by selecting them and clicking the delete button on your keyboard\n\n\nAdd a new 1-bit output RESULT\nMake all necessary connections by dragging as before to achieve a diagram like the one bellow:\n\n\nAgain, simulate the design and check the output remains correct as you change the values of the 4 inputs\nImproving the look of a schematic\nThe schematic here is not easy to read. Let\u0027s improve it! The ISSIE canvas is fully customisable to allow the creation of readable and good-looking schematics. Specifically, we can:\n\nRotate, Flip and Move all symbols\nChange name and reposition the symbols\u0027 labels relative to the symbols\nManually route any specific segment in a wire\nAuto-align elements\nSelect the desired wire type (radiussed, jump or modern wires)\n\nYou can view the shortcuts for all these modifications by clicking on the edit and view menus.\nThe improved schematic:\n\nSummary\n\nIn the Catalogue Menu we can find an extensive and complete library of components (gates, flip-flops, RAMs, ROMs, n-bit registers)\nWe can add any number of components in our sheet and name them as we like\nWhen clicking on a port, ISSIE shows us all the ports we can connect that port to: dragging from one port to another makes a wire.\nWires are initially automatically routed\nAuto-routing can be selectively over-ridden by manual routing to make a better-looking schematic.\nWe can simulate our design and check how the outputs change as we change the inputs.\n\nUsing Custom Components\nThe root schematic\nIn this section we will create a hierarchical design with multiple design sheets by using schematics as custom symbols in other design sheets. Here is the aim: The design we created earlier can be used in a larger design as a decoder of a 4-bit message to produce a true/false result. Therefore, we are going to create a schematic with an asynchronous-read 4-bit ROM using the schematic we created before as a custom symbol.\nSteps\n\nChange the name of the current sheet from main to decoder (Sheets -\u0026gt; rename)\nAdd a new sheet and name it main\n\nAdd to the main sheet:\n\nAsynchronous ROM (MEMORIES =\u0026gt; ROM (asynchronous)). Select 4 bits addressor, 4 bits data and the Enter data later option\nYour decoder (THIS PROJECT =\u0026gt; decoder)\n1-bit output named \u0027RESULT\u0027 (INPUT/OUTPUT =\u0026gt; Output)\n4-bit input named \u0027Addressor\u0027 (INPUT/OUTPUT =\u0026gt; Input)\n\n\nUsing 3 SplitWire components (BUSES =\u0026gt; SplitWire) separate the 4-bit ROM output to 4 1-bit wires. (see image below)\nMake the appropriate connections to achieve the schematic below\n\n\nImproving the design sheet\nIt\u0027s time to use a hidden part of the ISSIE UI to move ports on custom symbols. ISSIE allows you to re-order and change the side of input and output ports of custom symbols by CTRL \u002B CLICKING ON THE PORT you want to move. The UI, once you realise that you must keep Ctrl (Cmd on Macs) pressed, is intuitive.\nPreview how it works in the gif below:\n\nROM Initialisation\nCurrently our ROM is empty as we selected the option Enter Data Later before. Let\u0027s put some values in our ROM.\n\nSelect the ROM and click on the Properties tab\nClick on view/edit memory content\nChange the content of the 16 memory location available by assigning a random 4-bit number to each one\nClick done\n\nISSIE also allows ROM and RAM initialisation via .ram text files of hex data in the ISSIE directory. See the ISSIE Eratosthenes demo for an example of this. The memory component properties tab offers additional options when there  .ram files present.\nSimulation\nSimulate your design! Change the value of the addressor input and see whether your decoder produces a true or false result for each number you assigned to the ROM.\nWaveform Simulation\nCreating a clocked design\nLet\u0027s now modify our previous design to make it clocked (sequential). We use a counter to form a custom addressor that will increment every clock cycle. Using the waveform simulator we will be able to view the output of our circuit for all memory locations. In order to create such designs easily, ISSIE offers a Counter component which, starting from 0, increments by one every clock cycle. Note that counters also have options, under properties, to add Load or Enable inputs.\nAdd a Counter from the Catalogue (FLIP FLOPS AND REGISTERS). Now select the component and click on Properties. In properties remove the load and enable ports and give them the default functionality (which is what we want in this case): enable=1; load=0;\nEdit the previous design to create a schematic like the one below:\n\nSimulating your design\nAs soon as you connect everything correctly, You can simulate your design. Click on Simulations and then Wave Simulation.\n\nClick the Start Simulation button\nClick Select Waves\n\n\n\nClick the Main breadcrumb to filter so only main sheet ports are visible.\n\n\n\n\nSelect:\n\nAROM1 Addr\nCNT1 Q[3:0]\nDECODER1  RESULT\n\n\nClick Done\n\nTo check what you have selected:\n\nClick Select waves again\nClick Show only selected\nClick Done\n\n\nUse Select RAM to select the ROM contents to view.\nChange the data format to either hex or bin to make the waveforms more readable\nadjust the number of clock cycles displayed using the \u002B/- zoom controls.\nOrder the waveforms CNT1 / AROM1 / RESULT by dragging the waveform names up or down.\nCheck that the waveform simulator output matches your previous (Step Simulation) results.\nUse the scroll bar to view additional clock cycles.\nDrag the grey horizontal divider to make the waveform display wider or narrower (you can do this at any time).\nYou can check how these features work on a much larger design with 100,000 clock cycles using the Eratosthenes sieve demo.\n\n\nChanging your design\nNow, keeping the simulation open,  add an extra register between the counter and the ROM address (or make any other change you want) and check that the simulation has the expected output. You can see the changes in the waveform simulator by clicking the Refresh button which will be enabled as soon as there is a change in the schematic.\n\nTruth Table\nOne of ISSIE\u0027s features is the ability to view the truth table for a small combinational circuit.\n\nClick on Simulations and then Truth Table\nSelect the DECODER component\nClick on Generate Truth Table button on the \u0027Truth Table for selected logic\u0027 section\nClick on Remove Redundancies\nThe truth table should look like this:\n\n\nYou can also select your inputs to be algebraic values to get an expression for each of your outputs.\n\nClick on Back to full table\nClick on Algebra\nSelect the inputs (C, B, A) you want to be algebraic values\nTruth table should now look like this:\n\n\nVerilog Component\nLast but not least, ISSIE allows you to create combinational custom components by defining the logic in Verilog. Click on Verilog -\u0026gt; New Verilog Component (Catalogue) and write the logic of your decoder in Verilog.\n\n\nClick Save\nReplace the previous Decoder with the new one (found under Verilog section in the Catalogue)\nSimulate again your design. Everything should be the same as before.\n\nNow what?\nYou now know how to use ISSIE to create \u0026amp; simulate digital designs.\nYou can now create your designs (from simple circuits to fully functioning CPUs) and either simulate them or extract them as Verilog to use them with other tools.\nFor inspiration, look when you start ISSIE under the demos option  for Eratosthenes Sieve demo which consists of an EEP1 CPU running an Eratosthenes Sieve program written in EEP1 assembly language. The sieve occupies most of EEP1 RAM and the program takes 200,000 clock cycles to run.\n","headings":["Getting Started","Downloading and Running ISSIE","Creating a New Project","Your first design","Simulation","Exploiting the ISSIE Features","A slightly more complex design","Improving the look of a schematic","Summary","Using Custom Components","The root schematic","Steps","Improving the design sheet","ROM Initialisation","Simulation","Waveform Simulation","Creating a clocked design","Simulating your design","Changing your design","Truth Table","Verilog Component","Now what?"],"type":"content"},{"uri":"/issie/reports.html","title":"Technical Reports","content":"\nTechnical Reports on Issie\nThese reports document in detail the parts of Issie created by FYP students. HLP and Summer UTOP/UROP contributions do not come with such documentation!\n\n\n\nYear\nReport\nAuthor\nNotes\n\n\n\n\n2020\nThe original Issie design\nMarco Selvatici\nThe Schematic Editor and Simulator have been completely reworked since this.\n\n\n2022\nImplementing Truth Tables on Issie\nAditya Deshpande\nThe report does not fully describe all of the features that were implemented.\n\n\n2023\nThe Verilog Editor and Compiler\nPetra Ratkai\nRound 2 of the Verilog compiler work\n\n\n2023\nImproving the Simulator\nYujie Wang\nHow to improve performance\n\n\n2024\nPorting Issie to .Net\nKaiwen Liu\nAttempt to use Avalonia/.Net instead of HTML/CSS / Javascript\n\n\n\n\n","headings":["Technical Reports on Issie"],"type":"content"},{"uri":"/issie/updates/2025-04-09-five-years.html","title":"Five years of Issie","content":"\nFive years of Issie development: the good, the bad, and the ugly\nIssie development over 5 years has added roughly 10K lines of code per year. It has also required some refactoring to reduce technical debt where new features break the old structure. What are the merits and demerits of Issie\u0027s design as seen from a maintainer\u0027s perspective?\nElmish Model-View-Update\nNearly all of the Issie UI runs using a strict MVU architecture in which a single global model record (with many sub-records) holds all persistent state. The Elmish framework uses a React virtual DOM and allows global state to be distributed using React components. Issie does not do this and keeps all state in one place. Performance is obtained by caching parts of the View that do not change in a given update. Because we write pure functional code this is very easily done by comparing function inputs and not evaluating functions if they don\u0027t change.\nThis paradigm works very well. Different parts of Issie code do not have unexpected interactions because they use different parts of the state, and where they do change state what they do is transparent. As a result Issie development is robust. Features can safely be added, or code refactored, looking only at a small part of the code base and not understanding the rest. This is the expected result of functional programming but it was not obvious it would work well in a large application.\nThe initial Issie design used the open source general purpose Javascript drawing package Draw2D, with some small modifications to implement wires with specific bit-widths. This was problematic to interface to the rest of Issie, because it was stateful, and it was also very buggy. We redesigned the schematic editor in F# from scratch in year 2. The new design used three nested blocks dealing with sheet, wire, and symbol-level operations respectively using an SVG canvas. The three blocks work like react components and we tried originally to hide information so that for example symbol messages could only operate on symbol state. That worked well in general, but badly in a few specific cases. We have moved to a system with escape hatches that allows but discourages each block\u0027s code from sending messages that change a higher-level block\u0027s state.\nSince rewriting the schematic editor in F# we have had no significant bugs. The design has proven very robust and been enhanced with very many added features without any change to the basic structure. The schematic editor now comprises about 20K lines of code.\nF#\u0027s Enforced Layering of Software: no forward references\nF# is an opinionated language and the compiler originally had  a strict rule not allowing forward references. For F# 7 that was relaxed a bit, so that a module could be tagged recursive and have arbitrary forward references. The restriction between modules of no forward references remains.\nWe generally found that is code naturally layered so that this restriction was no problem. Because we have a near-strict functional programming paradigm it is easy to work out module boundaries.  We had one case - the waveform simulator, where the code as originally written was in a recursive module and seemed impossible to separate into layers. It was also extremely difficult to work with. A major refactoring of code (done in several stages) together with a reworking of the use of global state split this into 11 separate modules, none of which are recursive. The new code is much easier to work with than the old. So this is a case example of why writing code without forward references on a large scale correlates with more maintainable code. If you cannot do that: look again at your design.\nIssie currently has 4 recursive modules, all containing types and little else. It in general is impossible to avoid types that depend in a circular fashion on other types because message types  must reference implementation types, and (sometimes) implementation types must reference message types.\nFunctional Programming, mutable data, and recursion\nWe use guidelines for F# that discourage mutable data more than is typical in the language. For example, we do not use for loops and instead use List.map and so on. Very occasionally there are examples where an unbounded while loop is needed and implementing this through recursion seems artificial. But much more often we find that programmers need help to see that a declarative solution to a coding problem is possible and more readable than something using sequence. Even when forced not to use mutable variables a programmer will use linear recursion or folding - both of which effectively perform sequential update - unnecessarily.\nFrom our experience teaching programmers NOT to do this unnecessarily pays dividends.\nStudents find it surprising that they learn about recursion as the only way to implement iterative operations with immutable data, but then find in the Issie code base that there is very little recursion. Indeed recursion is officially a code smell in F#, and experience coding Issie has taught me this is true. Even so mutable variables are except in very special cases a worse sin than recursion.\nFor an example, given a collection of standard programming challenge problems involving lists or maps, classify solutions (all using immutable data) as follows:\n\nUsing neither linear recursion nor fold\nUsing linear recursion but not fold\nUsing neither linear recursion nor fold.\n\nIn general solutions of type 3 should be preferred over 2, and 2 preferred over 1. It is quite surprising how unnatural it is for programmers brought up with procedural programming to see a much simpler solution of type 3 instead of one of type 2 or 1. Partly this is unfamiliarity with available standard collection library functions. Partly it is that they automatically convert problems into procedural solutions.\nA great example.\n/// Given a list of non-duplicate integers, return a list of lists of consecutive integers containing the same values.\n/// You may assume the input list is sorted in ascending numerical order.\n/// Example: [1;2;3;5;6;7;10] -\u0026gt; [[1;2;3];[5;6;7];[10]]\nlet consecutiveLists (lst: int list) : int list list =\n    failwithf \u0026quot;not implemented\u0026quot;\n\nStudents were told to prefer solutions of type 3 over 2 over 1, and not allowed to use mutable variables. Even then only one in ten, without training to think declaratively, will solve this problem in the most natural, and easily simplest, way:\nlet declarativeConsecutiveLists (lst: int list) : int list list =\n    List.indexed lst // add positions in list\n    |\u0026gt; List.groupBy (fun (index,number) -\u0026gt; number - index) // consecutive integer sub-lists have constant (number - index)\n    |\u0026gt; List.map (fun (grp, grpLst) -\u0026gt; grpLst |\u0026gt; List.map snd) // remove positions\n\nShowing a class of programmers many such problems, asking them to each generate pencil and paper approximate solutions, and then comparing these, is a great way to reprogram brains into thinking declaratively when that is appropriate. The point being that when declarative solutions exist they are nearly always more readable than more implementation-focussed iterative, or iterative-equivalent using fold or recursion, solutions.\nUsing HTML and React for a GUI with Electron \u0026amp; FABLE.\nWe have had a good experience using Electron to write a desktop application a single-page front-end coded web app, even though our programmers are often inexperienced in web development. The code is all written in F#, not Javascript, and transpiled to javascript by FABLE. When developing Issie it is nearly always not necessary to think about javascript - the Electron API and HTML / CSS mostly can be written by someone with little front-end experience benefitting from a strongly typed DSL.\nHTML/CSS at its worst, when demanding UI behaviour is needed, has the full complexity of front-end development. But it allows complex responsive UIs that solve every problem, and the complexity is only needed when circumstances require it. Most of the time things are simple. The schematic editor uses Model-View-Update SVG throughout and this is a good solution with excellent performance and simple implementations.\nWe prefer to write everything in F# and minimise the dependence on external npm ecosystem packages: although electron has a lot of unavoidable dependencies.\nThe most unpleasant part of the technical stack for us is React. Its merit is that as a very well-optimised virtual DOM it allows us to run a big application as MVU. The partial DOM updates are optimised. We do not use the complexity of React (life cycle etc) at all. We do not even think about React, the View function implements HTML. Update events are generated from HTML event listeners. So the complexity of React is nearly all hidden.\nWe had last year a very unpleasant experience with an unexplained memory leak. We normally just can\u0027t get memory leaks, a functional style of programming makes that impossible, unless the Model contains unbounded data structures. In the end we traced this to an undocumented React 17 bug in not garbage collecting Ref hook references. This was fixed in React 18 with the fix never back-ported to React 17.\nFABLE is outstanding technology. We have never had problems with it, and thank Alfonso Garcia-Caro and its many contributors for its development.\nDeveloping the Issie simulator in F# has been challenging because we want both time and space performance. Understanding this requires knowledge of:\n\nF# compiler optimisations\nFABLE translation from F# to Javascript\nChromium JVM optimisations\n\nChromium is a JVM forked from the Chrome browser and used in Electron. The Chromium developers made a decision a few years ago to use compressed (32 bit) pointers in the heap. That limits the heap size to 4GB and practically, because of multiple space garbage collection, more like 2GB. This limitation is regrettable but baked into Chromium, for typical use cases the time advantage of pointer compression far outweighs the disadvantage of a space limitation.\nOur use case is not typical, and the heap size limit creates problems for Issie when simulating very large designs. We needed to implement simulation data storage using JS numeric typed arrays that are not stored in the heap by Chromium (the array elements need not be garbage collected) and therefore can be larger than 4GB. Doing this from F# is in fact quite straightfoward because numeric arrays in F# are translated to typed numeric arrays in Javascript: but it requires some care. If interested see Yujie\u0027s technical Report.\nOverall\nThe technical stack we use is unusually complex. To build Issie we need both .Net and Node (npm) package management. The build boilerplate is quite unpleasant. However, now it is sorted out, it has proven to be reliable and its complexity is irrelevant for developers.\nElectron itself does a very good job of making the generated binaries cross-platform. We run Issie on Windows, Macos, and Linux. Macos has become increasingly restrictive when running unsigned binaries so now, to avoid very unpleasant user setup, we need a paid developer\u0027s license to sign the Macos binaries.\nNow we spend much less time on boilerplate and tooling issues than we did at the start. FABLE has got easier to use, F# has become much more uniform cross-platform, and tools now install quickly without hassle. We can spend more time on productive coding, which usually, writing code in F#, is a very pleasant experience.\nRelatively inexperienced programmers have been able to make significant contributions to Issie. The paradigm we use avoids many of the bear traps of bad coding. Still we find it is best to train Issie programmers explicitly in how to write productive code in a declarative style and with proper use of names and function boundaries: it is possible to write bad code in any paradigm!\nFor me Issie has meant innovating a wide range of complex algorithms, exploring many different technologies, and discovering what matters when writing a \u0022no user manual should be required\u0022 user interface. All of these have been a great personal pleasure. That I am able to share this with many students is an especial joy.\nTom Clarke, April 2025.\n","headings":["Five years of Issie development: the good, the bad, and the ugly","Elmish Model-View-Update","F#\u0027s Enforced Layering of Software: no forward references","Functional Programming, mutable data, and recursion","Using HTML and React for a GUI with Electron \u0026amp; FABLE.","Overall"],"type":"content"},{"uri":"/issie/updates/2022-05-04-Issie-v3-0-0.html","title":"ISSIE v3.0.0","content":"\nISSIE v3.0.0\nOne year on and Issie has survived another year of intensive testing by EEE students with, this time, no significant bugs!\nThis Summer we have some significant upgrades, described below. With these, Issie is now up to 24K lines of F#!\nNew Schematic Editor: v3.0.0\nThe initial schematic editor could only autoroute from right edge outputs to left edge inputs. That was quite limiting and we were finding that with no ability to rotate or flip components designs were often badly routed. We partly fixed this by allowing custom component (subsheet instance) ports to be arbitrarily positioned but the UI for this was unpleasant and required chnaging component poistions on the underlying sheet.\nSo this year the HLP students were set the task of improving the schemetic editor, allowing arbitrary auto-routing, component rotating and flipping, MUXes with select inputs on a different edge from outputs and inputs. As is often the case they exceeded this brief and in v3.0.0 we have their work put together and tidied up, with very many enhancements over v2.\nPolishing: v3.0.0\nLittle things for usability, like recent project lists and a persistent load/save directory, have been implemented for greater usability, and all minor bugs except for waveform simulator top-level UI weirdness have been closed. The waveform simulator is currently being overhauled, hence its top-level UI will be part of that.\nWaveform Simulator\nThe code here is very complex and difficult to work with. It is being re-implemented with the idea that we can make it more interactive and add functionality. Since this is a student\u0027s project work the end result is still not clear! Expect results released in early July.\nStep Simulator\nThe step simulator is being reworked with some added feaures (another student project). Again exact functionality is still under consideration: expect results released in early July.\nLooking forward\nOver the Summer we hope for two major improvements:\n\nVerilog components. We will implement a verilog (subset) parser and allow at least combinational Verilog blocks as components.\nParametrised sheets. Library components in Issie are currently limited by the lack of sheet-level parameters (for example bus width). We would like to implement this so that complex components can be implemented as libraries.\n\nHave a look at the issues and associated discussions for where we are on these two projects - contribute if you are interested or have strong requirements.\n","headings":["ISSIE v3.0.0","New Schematic Editor: v3.0.0","Polishing: v3.0.0","Waveform Simulator","Step Simulator","Looking forward"],"type":"content"},{"uri":"/issie/updates/2022-09-20-Issie-v3-0-1.html","title":"ISSIE v3.0.1","content":"\nISSIE v3.0.1\nThe Summer has been highly productive for Issie, with work from Jason, Aditya, and Archontis - whose time working on a 6 month placement has been invaluable. I am very grateful for their help.\nWe have added another 11K lines of code to Issie. This comprises many new features, but also a lot of work to fix bugs and reduce technical debt. Part of this is\nwhat you might call user interface technical debt. As new features are added some of the initial UI design elements no longer work intuitively and so they must be reworked. This was true for the waveform simulation. We now have a redesigned user interface where step\nsimulation and waveform simulation work the same way and enhance each other. In addition the waveform Viewer now works without limitations on very large designs and allows design correction and resimulation\nwithout losing the simulation context. This should significantly speed up edit/debug cycles on larger designs.\nTwo other notable developments implemented by Archontis.\n\n\nWe have an initial Verilog entry window to allow complex combinational logic to be written as equations. Although the current impelmentation is a subset of\nVHDL it has two merits: the user in-editor error messages are instant and very understandable, and the parsing logic is implemented using a Nearley Parser. Nearley grammars are powerful and easy to write, they\nalso make it easy to get detailed and precise error messages from the parse - that is needed for a user-friendly Verilog entry system! Expanding Verilog input to the full language will be a future project, this is a secure foundation.\n\nWe have completed the interface to Issie stick hardware so that designs can be run on FPGAs and debugged (with Issie as debugger).\n\nFor me the most interesting take home has been the ease with which even a fairly large design (now 36K lines of F# in 60 files) can be reworked. This is a merit of the \u0022near functional\u0022 architecture using F# and Elmish MVU. Problems with technical debt have come from original code that breaks the Issie guidelines, or where requirements have changed so much that significant redesign is needed.\nTechnically, most interesting was integrating a Javascript Nearley parser, and adding Optics to make the syntax for nested state changes more readable. For users, we have a lot of little features and UI improvements too numerous to mention here that fill gaps in Issie making it a better CAD tool while keeping its extreme simplicity.\nWe are reasonably confident that the changes will make an even better experience for the new EEE 1st year DECA students!\nLooking forward: the two major improvements now wanted are a faster simulator more capable in big designs, and a complete Verilog language implementation.\nTom Clarke, September 2022\n","headings":["ISSIE v3.0.1"],"type":"content"},{"uri":"/issie/updates/2022-12-25-Issie-v3-0-9.html","title":"ISSIE v3.0.9  - Happy Christmas!","content":"\nISSIE v3.0.9  - Happy Christmas!\nHappy Christmas and New Year to all Issie users!\nThe major changes from last year have now survived Autumn Term testing with a few minor changes and fixes to improve the all-new waveform simulation display. Next term will have more serious user testing with a few hundred students using the waveform simulator to run and debug a multi-sheet EEP1 CPU.\nFor the period of the Spring term there will be no new features - and bug fixes as needed. We hope not many will be needed.\nThis year the main Issie improvement will be the simulator, where 0x6770 (Yujie Wang) is working on a branch that will use a variety of techniques to speed up simulation by a large amount. Yujie will also be making a few additions to the recommended Issie tool chain and style guide.\nIn addition a major extension is expected to the current simple Verilog component feature. Petra Ratkai petraratkai is working on a much more complete Verilog compiler that will move Issie more towards non-schematic use. The hope is that eventually for advanced work schematics can be used for structural code an top-level hierarchy, and RTL modules implemented in HDL.\nTom Clarke, December 2022\n","headings":["ISSIE v3.0.9  - Happy Christmas!"],"type":"content"},{"uri":"/issie/updates/2021-07-04-Issie-v2-1-0.html","title":"ISSIE v2.1.0","content":"\nISSIE v2.1.0\nIntroduction\nIssie came about when we were working out the coursework for a combined two-Term 1st year Digital Electronics and Computer Architecture module in the Electronic and Electrical Engineering Department, Imperial College London. For those interested it is Elec40003. We wanted coursework for introductory Digital Electronics, that would scale to simple CPU design, with hierarchical block schematic based design entry. We considered an HDL, and decided this was less intuitive and in any case the extra time learning an HDL could be better used. Schematics help in visualising signal flow and hierarchy - key concepts when first learning digital Electronics. There is also a strong case for preferring block schematic representation for the top-level structural levels of a design, even if the design is all written in an HDL.\nUpdates\nIt is now, v2.1.0, one year from when Issie was first created, and it has survived three terms of heavy use by 1st year undergraduates. The final working student designs, implemented from scratch with no pre-built blocks, were dual-core CPUs with cut-down ARM-like instruction set, UARTs, and IEEE 754 single precision FPUs. Designs were can output as Verilog and synthesised on FPGAs or (as additional validation) simulated with a Verilog simulator.\nThe original design created by Marco Selvatici (3rd year EEE student) has stood quite well, with two major changes:\n\nSimulation. the original (very clever) recursive functional simulator proved to be incapable of correctly representing circuits with complex subsheets that contain clocked and combinational logic. Also it was very slow. So we wrote, under pressure of student complex designs not quite working, a new simulator. This flattened the hierarchical design to a sea of Issie components and then determined a feasible fixed execution order for all components. It proved robust and also much, much, faster than the original simulation. Both of these qualities were needed!\nDrawing library. Issie originally depended on Draw2D - a big and very sophisticated Javascript draw library. The schematic editor used this and added custom (Javascript) digital component symbols. However the wire auto-router in this library that we wanted to use proved to be buggy (it would crash) and it was not easy to mend because the crash was an infinite loop through a lot of complex Draw2D repainting code. A completely new custom drawing library designed specifically for Issie was written by 3rd year students in EEE, and integrated with Issie. This was debugged through Summer Term issue usage and is now more usable than the original Draw2D library. This rewrite has a lot of advantages - the application is now all F#, the draw library is written as a fully MVU (Elm-like) web-style application without internal state, and the complete draw library is now much faster than the old Javascript one.\n\nThese changes and some other minor additions have pushed the code base from 8K lines F# to 17K lines. F# is a very concise language, so that is a significant program.\nIssie is run as an open source project but thus far all serious development has been internal to Imperial College London, from staff and students. We are now hoping that other people will be interested!\n","headings":["ISSIE v2.1.0","Introduction","Updates"],"type":"content"},{"uri":"/issie/updates/2025-04-04-Issie-v5-9-3.html","title":"ISSIE v5.9.3","content":"\nISSIE v5.9.x\nFor Issie development in 2025 we have:\n\n\n\nFeature\nAuthor(s)\nStatus\n\n\n\n\nWaveform selector\nHLP cohort 2025\nFinished\n\n\nWaveform tooltips\nTC\nFinished\n\n\nParameters\nHLP cohort 2025\nDue to be finished and integrated May\n\n\nVerilog Compiler\nFYP student\nDue to be finished June, Integrated July.\n\n\n\n\nWaveform selector\nThe old waveform selector was very difficult to navigate and confusing. The new selector uses a breadcrumb tree to select sheets and an optimised UI to select component ports. The selector UI was quite difficult to get right. Try it and let us know if it can be improved.\nWaveform tooltips\nThe waveform simulator greys out parts of non-binary waveforms where there is not enough room to print the waveform value. This is the only thing to do, but the loss of information is not nice. Tooltips solve this. Technically these tooltips break normal Issie development rules by using mutable variables and changing the DOM outside of Elmish MVU. The motivation for this is that they must have excellent time and space performance. Poor time performance is less usable, poor space performance impacts how large a design can be simulated. The code is quite short and can be found in the EvilHoverCache module. The mutability is local, so this does not much cause maintenance problems.\nThis feature finishes the obvious feature set needed for a waveform simulator with a pleasant and intuitive UI. There are as always other advanced features that we could add.\nParameters\nIssie has since the beginning had an inherent limitation in that designs cannot be parametrised, e.g. to make register files arbitrary bit-width. This year the HLP class worked on the problem of how to parametrise Issie design sheets. For example, an up/down counter could be designed as a single sheet and then used in a design multiple times as counters of different widths.\nThe problem is complex because a full solution has parameters can be defined using parameter expressions of other parameters. This means that a design can no longer be explored as a set of independent design sheets. The actual widths in a design sheet can have different values for different instances of the sheet in the design. Correctness of parameter values then becomes more difficult to explain with Issie-quality error messages.\nVerilog Compiler\nWe have an FYP student looking at how to extend the current Verilog editor and compiler. Our ambition is that Issie should be able to compile nearly all synthesisable Verilog that represents purely synchronous designs into Issie design sheets. These can then be simulated using Issie, and viewed as schematics. That will allow Issie to be used seamlessly to support HDL learning, and also make Issie more useful for research or commercial medium-scale design and test.\nThe vision is that eventually we make both of the transformations:\n\nIssie schematics -\u0026gt; Verilog output\nVerilog input -\u0026gt; Issie schematics\n\nComplete and nicely human readable so that an Issie schematic generated from Verilog, or Verilog output from a schematic,  makes it easy for a novice to understand Verilog hardware.\n","headings":["ISSIE v5.9.x","Waveform selector","Waveform tooltips","Parameters","Verilog Compiler"],"type":"content"},{"uri":"/issie/updates/2024-09-25-Issie-v5-2-0.html","title":"ISSIE v5.2.0","content":"\nISSIE v5.2.0\nOne of the challenges in Issie development is controlling technical debt. As a project mostly extended by University student project work, the balance between adding new functionailty and refactoring always favours functionality. Luckily we also have some paid work from students over the summer period when we can ask them to spend time on the more boring but equally important stuff.\nThis Summer the Issie upgrades have been mostly about reducing technical debt and mending bugs. Last year updates to React 17 introduced a very nasty memory leak bug in Issie #463 that was undiagnosed for a long time and made use on large designs very unpleasant.\nSo this Summer we spent some time fixing this and in teh process instrumenting garbage collection and testing Issie with long simulations of large designs, and redoing everything that broke under those conditions.\nThe new feature this Summer is a greatly improved Waveform Simulator with a long overdue scrollbar (credit Samuel Wang\u0027s UTOP work) to navigate the time axis when viewing waveforms.\nThere are many changes in the Waveform simulator detailed in the release the release.\nWe also have added a nice built-in demo of the EEP1 CPU simulated for 800,000 cycles as hardware and running code to generate the first 20,000 prime numbers using Eratosthenes Sieve - which is great for testing the waveform simulation features.\nIn the process of this work we did some refactoring of the two areas in Issie most problematic for development because they have been reworked so many times; the simulation and the waveform simulator. Both of these now have a modular structure that reflects the real work done, and modules small enough to make finding things easy.\nTom Clarke, September 2024\n","headings":["ISSIE v5.2.0"],"type":"content"}]